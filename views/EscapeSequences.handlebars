<h2>Escape Sequences (\char)</h2>



<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p>&nbsp;</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>TABLE OF CONTENTS <a id="show-toc" href="#show-toc">(HIDE)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header">
<h1>Regular Expressions (Regex)</h1>
</div>

<div id="content-main">


<p><em>Regular Expression</em>, or <em>regex</em> or <em>regexp</em> in short, is extremely and amazingly powerful in searching and manipulating text strings, particularly in processing text files. One line of regex can easily replace several dozen lines of programming codes.</p>
<p>Regex is supported in  all the scripting languages (such as Perl, Python, PHP, and JavaScript); as well as general purpose programming languages such as Java; and even word processors such as Word for searching texts. Getting started with regex may not be easy due to its geeky syntax, but it is certainly worth the investment of your time.</p>

<h3 id="byexamples">Regex By Examples</h3>

<p>This section is meant for those who need to refresh their memory. For novices, go to the next   section to learn the syntax, before looking at these examples.</p>

<h4 id="summary">Regex Syntax Summary</h4>
<ul>
<li><span class="line-heading">Character</span>: All characters, except those having special meaning in regex, matches themselves. E.g., the regex <code>x</code> matches substring <code>&quot;x&quot;</code>; regex <code>9</code> matches <code>&quot;9&quot;</code>; regex <code>=</code> matches <code>&quot;=&quot;</code>; and regex  <code>@</code> matches <code>&quot;@&quot;</code>.</li>
<li><span class="line-heading">Special Regex Characters</span>: These characters have special meaning in regex (to be discussed below): <code>.</code>, <code>+</code>, <code>*</code>, <code>?</code>, <code>^</code>, <code>$</code>, <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>{</code>, <code>}</code>, <code>|</code>, <code>\</code>.</li>

<li><span class="line-heading">Escape Sequences (<span class="font-code">\char</span>)</span>:
  <ul>
<li>To match a character having special meaning in regex, you need to use a escape sequence prefix with a backslash (<code>\</code>). E.g., <code>\.</code> matches <code>&quot;.&quot;</code>; regex <code>\+</code> matches <code>&quot;+&quot;</code>; and regex <code>\(</code> matches <code>&quot;(&quot;</code>.</li>
<li>You also need to use regex <code>\\</code> to match <code>&quot;\&quot;</code> (back-slash).</li>
<li>Regex recognizes common escape sequences such as <code>\n</code> for newline, <code>\t</code> for tab, <code>\r</code> for carriage-return, <code>\nnn</code> for a up to 3-digit octal number, <code>\xhh</code> for a two-digit hex code, <code>\uhhhh</code> for a 4-digit Unicode, <code>\uhhhhhhhh</code> for a 8-digit Unicode.</li>
  </ul>
</li>

<li><span class="line-heading">A Sequence of Characters (or String)</span>: Strings can be matched via combining a sequence of characters (called sub-expressions). E.g., the regex <code>Saturday</code> matches <code>&quot;Saturday&quot;</code>. The matching, by default, is case-sensitive, but can be set to case-insensitive via  <em>modifier</em>.</li>
<li><span class="line-heading">OR Operator (<span class="font-code">|</span>)</span>: E.g., the regex <code>four|4</code> accepts strings <code>&quot;four&quot;</code> or <code>&quot;4&quot;</code>.</li>

<li><span class="line-heading">Character class (or Bracket List)</span>:
  <ul>
    <li><span class="font-code">[...]</span>: Accept ANY ONE of the character within the square bracket, e.g., <code>[aeiou]</code> matches <code>&quot;a&quot;</code>, <code>&quot;e&quot;</code>, <code>&quot;i&quot;</code>, <code>&quot;o&quot;</code> or <code>&quot;u&quot;</code>.</li>
    <li><span class="font-code">[.-.]</span> (Range Expression): Accept ANY ONE of the character in the <em>range</em>, e.g., <code>[0-9]</code> matches any digit; <code>[A-Za-z]</code> matches any uppercase or lowercase letters.</li>
    <li><span class="font-code">[^...]</span>: NOT ONE of the character, e.g., <code>[^0-9]</code> matches any non-digit.</li>
    <li>Only these four characters require escape sequence inside the bracket list: <code>^</code>, <code>-</code>, <code>]</code>, <code>\</code>.</li>
  </ul>
</li>

<li><span class="line-heading">Occurrence Indicators (or Repetition Operators)</span>:
  <ul>
    <li><span class="font-code">+</span>: one or more (<code>1+</code>), e.g., <code>[0-9]+</code> matches one or more digits such as <code>'123'</code>, <code>'000'</code>.</li>
    <li><span class="font-code">*</span>: zero or more (<code>0+</code>), e.g., <code>[0-9]*</code> matches zero or more digits. It accepts all those in <code>[0-9]+</code> plus the empty string.</li>
    <li><span class="font-code">?</span>: zero or one (optional), e.g., <code>[+-]?</code> matches an optional <code>&quot;+&quot;</code>, <code>&quot;-&quot;</code>, or an empty string.</li>
    <li><span class="font-code">{m,n}</span>: <code>m</code> to <code>n</code> (both inclusive)</li>
    <li><span class="font-code">{m}</span>: exactly <code>m</code> times</li>
    <li><span class="font-code">{m,}</span>: <code>m</code> or more (<code>m+</code>)</li>
  </ul>
</li>

<li><span class="line-heading">Metacharacters</span>: matches a character
  <ul>
    <li><span class="font-code">.</span> (dot): ANY ONE character except newline. Same as <code>[^\n]</code></li>
    <li><span class="font-code">\d</span>, <span class="font-code">\D</span>: ANY ONE digit/non-digit character. Digits are <code>[0-9]</code></li>
    <li><span class="font-code">\w</span>, <span class="font-code">\W</span>: ANY ONE word/non-word character. For ASCII, word characters are <code>[a-zA-Z0-9_]</code></li>
    <li><span class="font-code">\s</span>, <span class="font-code">\S</span>: ANY ONE space/non-space character. For ASCII, whitespace characters are <code>[ \n\r\t\f]</code></li>
  </ul>
</li>

<li><span class="line-heading">Position Anchors</span>: does not match character, but position such as start-of-line, end-of-line, start-of-word and end-of-word.
  <ul>
    <li><span class="font-code">^</span>, <span class="font-code">$</span>: start-of-line and end-of-line respectively. E.g., <code>^[0-9]$</code> matches a numeric string.</li>
    <li><span class="font-code">\b</span>: boundary of word, i.e., start-of-word or end-of-word. E.g., <code>\bcat\b</code> matches the word <code>&quot;cat&quot;</code> in the input string.</li>
    <li><span class="font-code">\B</span>: Inverse of \b, i.e., non-start-of-word or non-end-of-word.</li>
    <li><span class="font-code">\&lt;</span>, <span class="font-code">\&gt;</span>: start-of-word and end-of-word respectively, similar to <code>\b</code>. E.g., <code>\&lt;cat\&gt;</code> matches the word <code>&quot;cat&quot;</code> in the input string.</li>
    <li><span class="font-code">\A</span>, <span class="font-code">\Z</span>: start-of-input and end-of-input respectively.</li>
  </ul>
</li>

<li><span class="line-heading">Parenthesized Back References</span>:
<ul>
<li>Use parentheses <code>( )</code> to create a back reference.</li>
<li>Use <code>$1</code>, <code>$2</code>, ... (Java, Perl, JavaScript) or <code>\1</code>, <code>\2</code>, ... (Python) to retreive the back references in sequential order.</li>
</ul>
</li>

<li><span class="line-heading">Laziness (Curb Greediness for Repetition Operators)</span>: <code>*?</code>, <code>+?</code>, <code>??</code>, <code>{m,n}?</code>, <code>{m,}?</code></li>


</ul>

<h4 id="numbers">Example: Numbers <span class="font-code color-new">[0-9]+</span> or <span class="font-code color-new">\d+</span></h4>

<ol>
<li>A regex (<em>regular expression</em>) consists of a sequence of <em>sub-expressions</em>. In this example, <code>[0-9]</code> and <code>+</code>.</li>

<li>The <code>[...]</code>, known as <em>character class</em> (or <em>bracket list</em>), encloses a list of characters. It matches any SINGLE character in the list. In this example, <code>[0-9]</code> matches any SINGLE character between 0 and 9 (i.e., a digit), where dash (<code>-</code>) denotes the <em>range</em>.</li>

<li>The <code>+</code>, known as <em>occurrence indicator</em> (or <em>repetition operator</em>), indicates one or more occurrences (<code>1+</code>) of the previous sub-expression. In this case, <code>[0-9]+</code> matches one or more digits.</li>

<li>A regex may match a portion of the input (i.e., substring) or the entire input. In fact, it could match zero or more substrings of the input (with global modifier).</li>

<li>This regex matches any numeric substring (of digits 0 to 9) of the input. For examples,
  <ol>
<li>If the input is <code>&quot;abc123xyz&quot;</code>, it matches substring <code>&quot;123&quot;</code>.</li>
<li>If the input is <code>&quot;abcxyz&quot;</code>, it matches nothing.</li>
<li>If the input is <code>&quot;abc00123xyz456_0&quot;</code>, it matches substrings <code>&quot;00123&quot;</code>, <code>&quot;456&quot;</code> and <code>&quot;0&quot;</code> (three matches).</li>
</ol>
Take note that this regex matches number with leading zeros, such as <code>&quot;000&quot;</code>, <code>&quot;0123&quot;</code> and <code>&quot;0001&quot;</code>, which may not be desirable.</li>

<li>You can also write <code>\d+</code>, where <code>\d</code> is known as a <em>metacharacter</em> that matches any digit (same as <code>[0-9]</code>). There are more than one ways to write a regex! Take note that many programming languages (C, Java, JavaScript, Python) use backslash <code>\</code> as the prefix for escape sequences (e.g., <code>\n</code> for newline<code></code>), and you need to write  <code>&quot;\\d+&quot;</code> instead.</li>
</ol>

<h4>Code Examples (Python, Java, JavaScript, Perl, PHP)</h4>
<h5>Code Example in Python</h5>
<p>See &quot;<a href="../webprogramming/Python1_Basics.html#re">Python's <code>re</code> module for Regular Expression</a>&quot; for full coverage.</p>
<p>Python supports Regex via module <code>re</code>. Python also uses backslash (<code>\</code>) for escape sequences (i.e., you need to write <code>\\</code> for <code>\</code>, <code>\\d</code> for <code>\d</code>), but it supports raw string in the form of <code>r'...'</code>, which ignore the interpretation of escape sequences - great for writing regex.</p>
<pre class="color-example">
<span class="color-comment"># Test under the Python Command-Line Interpreter</span>
$ <strong>python3</strong>
......
&gt;&gt;&gt; <strong>import re</strong>   <span class="color-comment"># Need module 're' for regular expression</span>

<span class="color-comment"># Try find: re.findall(<em>regexStr</em>, <em>inStr</em>) -&gt; <em>matchedSubstringsList</em>
# r'...' denotes raw strings which ignore escape code, i.e., r'\n' is '\'+'n'</span>
&gt;&gt;&gt; <strong>re.findall(r'[0-9]+', 'abc123xyz')</strong>
['123']   <span class="color-comment"># Return a list of matched substrings</span>
&gt;&gt;&gt; <strong>re.findall(r'[0-9]+', 'abcxyz')</strong>
[]
&gt;&gt;&gt; <strong>re.findall(r'[0-9]+', 'abc00123xyz456_0')</strong>
['00123', '456', '0']
&gt;&gt;&gt; <strong>re.findall(r'\d+', 'abc00123xyz456_0')</strong>
['00123', '456', '0']

<span class="color-comment"># Try substitute: re.sub(<em>regexStr</em>, <em>replacementStr</em>, <em>inStr</em>) -&gt; <em>outStr</em></span>
&gt;&gt;&gt; <strong>re.sub(r'[0-9]+', r'*', 'abc00123xyz456_0')</strong>
'abc*xyz*_*'

<span class="color-comment"># Try substitute with count: re.subn(<em>regexStr</em>, <em>replacementStr</em>, <em>inStr</em>) -&gt; (<em>outStr</em>, <em>count</em>)</span>
&gt;&gt;&gt; <strong>re.subn(r'[0-9]+', r'*', 'abc00123xyz456_0')</strong>
('abc*xyz*_*', 3)   <span class="color-comment"># Return a tuple of output string and count</span></pre>

<h5>Code Example in Java</h5>
<p>See &quot;<a href="../java/Java_Regexe.html">Regular Expressions (Regex) in Java</a>&quot; for full coverage.</p>
<p>Java supports Regex in package <code>java.util.regex</code>.</p>
<table class="table-program">
  <col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre></td>
<td>
<pre>
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class <strong>TestRegexNumbers</strong> {
   public static void main(String[] args) {

      String inputStr = &quot;abc00123xyz456_0&quot;;  <span class="color-comment">// Input String for matching</span>
      String regexStr = &quot;[0-9]+&quot;;            <span class="color-comment">// Regex to be matched</span>

      <span class="color-comment">// Step 1: Compile a regex via static method Pattern.compile(), default is case-sensitive</span>
      <span class="color-new">Pattern pattern = Pattern.compile(regexStr)</span>;
      <span class="color-comment">// Pattern.compile(regex, Pattern.CASE_INSENSITIVE);  // for case-insensitive matching</span>

      <span class="color-comment">// Step 2: Allocate a matching engine from the compiled regex pattern,</span>
      <span class="color-comment">//         and bind to the input string</span>
      <span class="color-new">Matcher matcher = pattern.matcher(inputStr)</span>;

      <span class="color-comment">// Step 3: Perform matching and Process the matching results</span>
      <span class="color-comment">// Try Matcher.find(), which finds the next match</span>
      while (<span class="color-new">matcher.find()</span>) {
         System.out.println(&quot;find() found substring \&quot;&quot; + <span class="color-new">matcher.group()</span>
               + &quot;\&quot; starting at index &quot; + <span class="color-new">matcher.start()</span>
               + &quot; and ending at index &quot; + <span class="color-new">matcher.end()</span>);
      }

      <span class="color-comment">// Try Matcher.matches(), which tries to match the ENTIRE input (^...$)</span>
      if (<span class="color-new">matcher.matches()</span>) {
         System.out.println(&quot;matches() found substring \&quot;&quot; + matcher.group()
               + &quot;\&quot; starting at index &quot; + matcher.start()
               + &quot; and ending at index &quot; + matcher.end());
      } else {
         System.out.println(&quot;matches() found nothing&quot;);
      }

      <span class="color-comment">// Try Matcher.lookingAt(), which tries to match from the START of the input (^...)</span>
      if (<span class="color-new">matcher.lookingAt()</span>) {
         System.out.println(&quot;lookingAt() found substring \&quot;&quot; + matcher.group()
               + &quot;\&quot; starting at index &quot; + matcher.start()
               + &quot; and ending at index &quot; + matcher.end());
      } else {
         System.out.println(&quot;lookingAt() found nothing&quot;);
      }

      <span class="color-comment">// Try Matcher.replaceFirst(), which replaces the first match</span>
      String replacementStr = &quot;**&quot;;
      String outputStr = <span class="color-new">matcher.replaceFirst(replacementStr)</span>; <span class="color-comment">// first match only</span>
      System.out.println(outputStr);

      <span class="color-comment">// Try Matcher.replaceAll(), which replaces all matches</span>
      replacementStr = &quot;++&quot;;
      outputStr = <span class="color-new">matcher.replaceAll(replacementStr)</span>; <span class="color-comment">// all matches</span>
      System.out.println(outputStr);
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>The output is:</p>
<pre class="output">
find() found substring &quot;00123&quot; starting at index 3 and ending at index 8
find() found substring &quot;456&quot; starting at index 11 and ending at index 14
find() found substring &quot;0&quot; starting at index 15 and ending at index 16
matches() found nothing
lookingAt() found nothing
abc**xyz456_0
abc++xyz++_++</pre>

<h5>Code Example in Perl</h5>

<p>See &quot;<a href="../webprogramming/Perl2_Regexe.html#regex">Regular Expression (Regex) in Perl</a>&quot; for full coverage.</p>

<p>Perl makes extensive use of regular expressions with many built-in syntaxes and operators. In  Perl (and JavaScript), a regex is delimited by  a pair of forward slashes (default), in the form of <code>/<em>regex</em>/</code>. You can use built-in operators:</p>

<ul>
<li><span class="font-code color-new">m/<em>regex</em>/<em>modifier</em></span> or <span class="font-code color-new">/<em>regex</em>/<em>modifier</em></span>: Match against the <code><em>regex</em></code>. <code>m</code> is optional.</li>
<li><span class="font-code color-new">s/<em>regex</em>/<em>replacement</em>/<em>modifier</em></span>: Substitute matched substring(s) by the replacement.</li>
</ul>

<p>In Perl, you can use single-quoted non-interpolating string <code>'....'</code> to write regex to disable interpretation of backslash (<code>\</code>) by Perl.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre>
</td>
<td>
<pre>
<span class="color-comment">#!/usr/bin/env perl</span>
use strict;
use warnings;

my $inStr = 'abc00123xyz456_0';  <span class="color-comment"># input string</span>
my $regex = '[0-9]+';            <span class="color-comment"># regex pattern string in non-interpolating string</span>

<span class="color-comment"># Try match /regex/modifiers (or m/regex/modifiers)</span>
my @matches = (<span class="color-new">$inStr =~ /$regex/g</span>);  <span class="color-comment"># Match $inStr with regex with global modifier</span>
<span class="color-comment">                                      # Store all matches in an array</span>
print &quot;@matches\n&quot;;   <span class="color-comment"># Output: 00123 456 0</span>

<span class="color-comment"></span>while (<span class="color-new">$inStr =~ /$regex/g</span>) {
   <span class="color-comment"># The built-in array variables @- and @+ keep the start and end positions</span>
   <span class="color-comment">#   of the matches, where $-[0] and $+[0] is the full match, and</span>
   <span class="color-comment">#   $-[n] and $+[n] for back references $1, $2, etc.</span>
   print substr($inStr, $-[0], $+[0] - $-[0]), ', ';   <span class="color-comment"># Output: 00123, 456, 0,</span>
}
print &quot;\n&quot;;

<span class="color-comment"># Try substitute  s/regex/replacement/modifiers</span>
<span class="color-new">$inStr =~ s/$regex/**/g</span>;    <span class="color-comment"># with global modifier</span>
print &quot;$inStr\n&quot;;           <span class="color-comment"># Output: abc**xyz**_**</span></pre>
</td>
</tr>
</tbody>
</table>

<h5>Code Example in JavaScript</h5>
<p>See &quot;<a href="../webprogramming/JavaScript_Introduction.html#regex">Regular Expression in JavaScript</a>&quot; for full coverage.</p>
<p>In  JavaScript (and Perl), a regex is delimited by  a pair of forward slashes, in the form of <code>/.../</code>. There are two sets of methods, issue via a <code>RegEx</code> object or a <code>String</code> object.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46</pre>
</td>
<td>
<pre>
&lt;!DOCTYPE html&gt;
<span class="color-comment">&lt;!-- JSRegexNumbers.html --&gt;</span>
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;JavaScript Example: Regex&lt;/title&gt;
&lt;script&gt;
var inStr = &quot;abc123xyz456_7_00&quot;;

<span class="color-comment">// Use RegExp.test(inStr) to check if inStr contains the pattern</span>
console.log(/[0-9]+/.test(inStr));  <span class="color-comment">// true</span>

<span class="color-comment">// Use String.search(regex) to check if the string contains the pattern</span>
<span class="color-comment">// Returns the start position of the matched substring or -1 if there is no match</span>
console.log(inStr.search(/[0-9]+/));  <span class="color-comment">// 3</span>

<span class="color-comment">// Use String.match() or RegExp.exec() to find the matched substring,</span>
<span class="color-comment">//   back references, and string index</span>
console.log(inStr.match(/[0-9]+/));  <span class="color-comment">// [&quot;123&quot;, input:&quot;abc123xyz456_7_00&quot;, index:3, length:&quot;1&quot;]</span>
console.log(/[0-9]+/.exec(inStr));   <span class="color-comment">// [&quot;123&quot;, input:&quot;abc123xyz456_7_00&quot;, index:3, length:&quot;1&quot;]</span>

<span class="color-comment">// With g (global) option</span>
console.log(inStr.match(/[0-9]+/g));  <span class="color-comment">// [&quot;123&quot;, &quot;456&quot;, &quot;7&quot;, &quot;00&quot;, length:4]</span>

<span class="color-comment">// RegExp.exec() with g flag can be issued repeatedly.</span>
<span class="color-comment">// Search resumes after the last-found position (maintained in property RegExp.lastIndex).</span>
var pattern = /[0-9]+/g;
var result;
while (result = pattern.exec(inStr)) {
   console.log(result);
   console.log(pattern.lastIndex);
      <span class="color-comment">// [&quot;123&quot;],  6</span>
      <span class="color-comment">// [&quot;456&quot;], 12</span>
      <span class="color-comment">// [&quot;7&quot;],   14</span>
      <span class="color-comment">// [&quot;00&quot;],  17</span>
}

<span class="color-comment">// String.replace(regex, replacement):</span>
console.log(inStr.replace(/\d+/, &quot;**&quot;));   <span class="color-comment">// abc**xyz456_7_00</span>
console.log(inStr.replace(/\d+/g, &quot;**&quot;));  <span class="color-comment">// abc**xyz**_**_**</span>
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Hello,&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</td>
</tr>
</tbody>
</table>

<h5>Code Example in PHP</h5>
<p>[TODO]</p>


<h4 id="fullnumbers">Example: Full Numeric Strings <span class="font-code color-new">^[0-9]+$</span> or <span class="font-code color-new">^\d+$</span></h4>
<ol>

<li>The leading <code>^</code> and the trailing <code>$</code> are known as <em>position anchors</em>, which match the start and end positions of the line, respectively. As the result, the entire input string shall be matched fully, instead of a portion of the input string (substring).</li>

<li>This regex matches any non-empty numeric strings (comprising of digits 0 to 9), e.g., &quot;<code>0</code>&quot; and &quot;<code>12345</code>&quot;. It does not match with &quot;&quot; (empty string), &quot;<code>abc</code>&quot;, &quot;<code>a123</code>&quot;, &quot;<code>abc123xyz</code>&quot;, etc. However, it also matches &quot;<code>000</code>&quot;, &quot;<code>0123</code>&quot; and &quot;<code>0001</code>&quot; with leading zeros.</li>
</ol>


<h4 id="positive_integer">Example: Positive Integer Literals <span class="font-code color-new">[1-9][0-9]*|0</span> or <span class="font-code color-new">[1-9]\d*|0</span></h4>
<ol>
<li><code>[1-9]</code> matches any character between 1 to 9; <code>[0-9]*</code> matches zero or more digits. The <code>*</code> is an <em>occurrence indicator</em> representing zero or more occurrences. Together, <code>[1-9][0-9]*</code> matches any numbers without a leading zero.</li>

<li><code>|</code> represents the OR operator; which is used to include the number <code>0</code>.</li>

<li>This expression matches &quot;<code>0</code>&quot; and &quot;<code>123</code>&quot;; but does not match &quot;<code>000</code>&quot; and &quot;<code>0123</code>&quot; (but see below).</li>

<li>You can replace <code>[0-9]</code> by metacharacter <code>\d</code>, but not <code>[1-9]</code>.</li>

<li>We did not use <em>position anchors</em> <code>^</code> and <code>$</code> in this regex. Hence, it can match any parts of the input string. For examples,
<ol>
<li>If the input string is &quot;<code>abc123xyz</code>&quot;, it matches the substring <code>&quot;123&quot;</code>.</li>
<li>If the input string is <code>&quot;abcxyz&quot;</code>, it matches nothing.</li>
<li>If the input string is <code>&quot;abc123xyz456_0&quot;</code>, it matches substrings <code>&quot;123&quot;</code>, <code>&quot;456&quot;</code> and <code>&quot;0&quot;</code> (three matches).</li>
<li>If the input string is <code>&quot;0012300&quot;</code>, it matches substrings: <code>&quot;0&quot;</code>, <code>&quot;0&quot;</code> and <code>&quot;12300&quot;</code> (three matches)!!!</li>
</ol></li>
</ol>

<h4 id="integers">Example: Full Integer Literals<span class="font-code color-new"> ^[+-]?[1-9][0-9]*|0$</span> or <span class="font-code color-new">^[+-]?[1-9]\d*|0$</span></h4>

<ol>
<li>This regex match an Integer literal (for entire string with the <em>position anchors</em>), both positive, negative and zero.</li>
<li><code>[+-] </code> matches either <code>+</code> or <code>-</code> sign. <code>?</code> is an <em>occurrence indicator</em> denoting 0 or 1 occurrence, i.e. optional. Hence, <code>[+-]?</code> matches an optional leading <code>+</code> or <code>-</code> sign.</li>
<li>We have covered three occurrence indicators: <code>+</code> for one or more, <code>*</code> for zero or more, and <code>?</code> for zero or one.</li>
</ol>

<h4 id="identifiers">Example: Identifiers (or Names) <span class="font-code color-new">[a-zA-Z_][0-9a-zA-Z_]*</span> or <span class="font-code color-new">[a-zA-Z_]\w*</span></h4>
<ol>
<li>Begin with one letters or underscore, followed by zero or more digits, letters and underscore.</li>
<li>You can use <em>metacharacter</em> <code>\w</code> for a word character <code>[a-zA-Z0-9_]</code>. Recall that <em>metacharacter</em> <code>\d</code> can be used for a digit <code>[0-9]</code>.</li>
</ol>

<h4 id="imagefilenames">Example: Image Filenames <span class="font-code color-new">^\w+\.(gif|png|jpg|jpeg)$</span></h4>

<ol>
<li>The <em>position anchors</em> <code>^</code> and  <code>$</code> match the beginning and the ending of the input string, respectively. That is, this regex shall match the entire input string, instead of a part of the input string (substring).</li>

<li><code>\w+</code> matches one or more word characters (same as <code>[a-zA-Z0-9_]+</code>).</li>

<li><code>\.</code> matches the dot <code>(.)</code> character. We need to use <code>\.</code> to represent <code>.</code> as <code>.</code> has special meaning in regex. The <code>\</code> is known as the escape code, which restore the original literal meaning of the following character. Similarly, <code>*</code>, <code>+</code>, <code>?</code> (occurrence indicators), <code>^</code>, <code>$</code> (position anchors) have special meaning in regex. You need to use an escape code to match with these characters.</li>

<li><code>(gif|png|jpg|jpeg)</code> matches either &quot;<code>gif</code>&quot;, &quot;<code>png</code>&quot;, &quot;<code>jpg</code>&quot; or &quot;<code>jpeg</code>&quot;. The <code>|</code> denotes &quot;OR&quot; operator. The parentheses are used for grouping the selections.</li>

<li>The <em>modifier</em> <code>i</code> after the regex specifies case-insensitive matching (applicable to some languages like Perl and JavaScript only). That is, it accepts &quot;<code>test.GIF</code>&quot; and &quot;<code>TesT.Gif</code>&quot;.</li>
</ol>

<h4 id="emails">Example: Email Addresses <span class="font-code color-new">^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$</span></h4>
<ol>
<li>The <em>position anchors</em> <code>^</code> and <code>$</code> match the beginning and the ending of the input string, respectively. That is, this regex shall match the entire input string, instead of a part of the input string (substring).</li>
<li><code>\w+</code> matches 1 or more word characters (same as <code>[a-zA-Z0-9_]+</code>).</li>
<li><code>[.-]?</code> matches an optional character <code>.</code> or <code>-</code>. Although dot (<code>.</code>) has special meaning in regex, in a character class (square brackets) any characters except <code>^</code>, <code>-</code>, <code>]</code> or <code>\</code> is a literal, and do not require escape sequence.</li>
<li><code>([.-]?\w+)*</code> matches 0 or more occurrences of <code>[.-]?\w+</code>.</li>
<li>The sub-expression <code>\w+([.-]?\w+)*</code> is used to match the username in the email, before the <code>@</code> sign. It begins with at least one word character <code>[a-zA-Z0-9_]</code>, followed by more word characters or <code>.</code> or <code>-</code>. However, a <code>.</code> or <code>-</code> must follow by a word character <code>[a-zA-Z0-9_]</code>. That is, the input string cannot begin with <code>.</code> or <code>-</code>; and cannot contain &quot;<code>..</code>&quot;, &quot;<code>--</code>&quot;, &quot;<code>.-</code>&quot; or &quot;<code>-.</code>&quot;. Example of valid string are &quot;<code>a.1-2-3</code>&quot;.</li>
<li>The <code>@</code> matches itself. In regex, all characters other than those having special meanings matches itself, e.g., <code>a</code> matches <code>a</code>, <code>b</code> matches <code>b</code>, and etc.</li>
<li>Again, the sub-expression <code>\w+([.-]?\w+)*</code> is used to match the email domain name, with the same pattern as the username described above.</li>
<li>The sub-expression <code>\.\w{2,3}</code> matches a <code>.</code> followed by two or three word characters, e.g., &quot;<code>.com</code>&quot;, &quot;<code>.edu</code>&quot;, &quot;<code>.us</code>&quot;, &quot;<code>.uk</code>&quot;, &quot;<code>.co</code>&quot;.</li>
<li><code>(\.\w{2,3})+</code> specifies that the above sub-expression could occur one or more times, e.g., &quot;<code>.com</code>&quot;, &quot;<code>.co.uk</code>&quot;, &quot;<code>.edu.sg</code>&quot; etc.</li>
</ol>

<p><span class="line-heading">Exercise:</span> Interpret this regex, which provide another representation of email address: <code>^[\w\-\.\+]+\@[a-zA-Z0-9\.\-]+\.[a-zA-z0-9]{2,4}$</code>.</p>

<h4 id="swapwords">Example: Swapping Words using Parenthesized Back-References <span class="font-code color-new">^(\S+)\s+(\S+)$</span> and <span class="font-code color-new">$2 $1</span></h4>

<ol>
<li>The <code>^</code> and <code>$</code> match the beginning and ending of the input string, respectively.</li>

<li>The <code>\s</code> (lowercase <code>s</code>) matches a whitespace (blank, tab <code>\t</code>, and newline <code>\r</code> or <code>\n</code>). On the other hand, the <code>\S+</code> (uppercase <code>S</code>) matches anything that is NOT matched by <code>\s</code>, i.e., non-whitespace. In regex, the uppercase metacharacter denotes the <em>inverse</em> of the lowercase counterpart, for example, <code>\w</code> for word character and <code>\W</code> for non-word character; <code>\d</code> for digit and <code>\D</code> or non-digit.</li>

<li>The above regex matches two words (without white spaces) separated by one or more whitespaces.</li>

<li>Parentheses <code>()</code> have two meanings in regex:
<ol>
<li>to group sub-expressions, e.g., <code>(abc)*</code></li>
<li>to provide a so-called <em>back-reference</em> for capturing and extracting matches.</li>
</ol></li>

<li>The parentheses in <code>(\S+)</code>, called <em>parenthesized back-reference</em>, is used to extract the matched substring from the input string. In this regex, there are two <code>(\S+)</code>, match the first two words, separated by one or more whitespaces <code>\s+</code>. The two matched words are extracted from the input string and typically kept in special variables <code>$1</code> and <code>$2</code> (or <code>\1</code> and <code>\2</code> in Python), respectively.</li>

<li>To swap the two words, you can access the special variables, and print &quot;<code>$2 $1</code>&quot; (via a programming language); or substitute operator &quot;<code>s/(\S+)\s+(\S+)/$2 $1/</code>&quot; (in Perl).</li>
</ol>

<h5>Code Example in Python</h5>
<p>Python keeps the parenthesized back references in <code>\1</code>, <code>\2</code>, .... Also, <code>\0</code> keeps the entire match.</p>
<pre class="color-example">
$ <strong>python3</strong>
&gt;&gt;&gt; <strong>re.findall(r'^(\S+)\s+(\S+)$', 'apple orange')</strong>
[('apple', 'orange')]     <span class="color-comment"># A list of tuples if the pattern has more than one back references</span>
<span class="color-comment"># Back references are kept in \1, \2, \3, etc.</span>
&gt;&gt;&gt; <strong>re.sub(r'^(\S+)\s+(\S+)$', r'\2 \1', 'apple orange')</strong>   <span class="color-comment"># Prefix r for raw string which ignores escape</span>
'orange apple'
&gt;&gt;&gt; <strong>re.sub(r'^(\S+)\s+(\S+)$', '\\2 \\1', 'apple orange')</strong>  <span class="color-comment"># Need to use \\ for \ for regular string</span>
'orange apple'</pre>

<h5>Code Example in Java</h5>
<p>Java keeps the parenthesized back references in <code>$1</code>, <code>$2</code>, ....</p>
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre>
</td>
<td>
<pre>
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class <strong>TestRegexSwapWords</strong> {
   public static void main(String[] args) {
      String inputStr = &quot;apple orange&quot;;
      String regexStr = &quot;<span class="color-new">^(\\S+)\\s+(\\S+)$</span>&quot;;  <span class="color-comment">// Regex pattern to be matched</span>
      String replacementStr = &quot;<span class="color-new">$2 $1</span>&quot;;         <span class="color-comment">// Replacement pattern with back references</span>

      <span class="color-comment">// Step 1: Allocate a Pattern object to compile a regex</span>
      Pattern pattern = Pattern.compile(regexStr);

      <span class="color-comment">// Step 2: Allocate a Matcher object from the Pattern, and provide the input</span>
      Matcher matcher = pattern.matcher(inputStr);

      <span class="color-comment">// Step 3: Perform the matching and process the matching result</span>
      String outputStr = matcher.replaceFirst(replacementStr); <span class="color-comment">// first match only</span>
      System.out.println(outputStr);   <span class="color-comment">// Output: orange apple</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4 id="http_addresses">Example: HTTP Addresses <span class="font-code color-new">^http:\/\/\S+(\/\S+)*(\/)?$</span></h4>
<ol>
<li>Begin with <code>http://</code>. Take note that you may need to write <code>/</code> as <code>\/</code> with an escape code in some languages (JavaScript, Perl).</li>
<li>Followed by <code>\S+</code>, one or more non-whitespaces, for the domain name.</li>
<li>Followed by <code>(\/\S+)*</code>, zero or more &quot;/...&quot;, for the sub-directories.</li>
<li>Followed by <code>(\/)?</code>, an optional (0 or 1) trailing <code>/</code>, for directory request.</li>
</ol>

<h4 id="angularjs">Example: Regex Patterns in AngularJS</h4>

<p>The following rather complex regex patterns are used by AngularJS in JavaScript syntax:</p>

<pre class="color-example">
var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;

var URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;

var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&amp;'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&amp;'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
<span class="color-comment">// Match both uppercase and lowercase letters, single-quote but not double-quote</span>

var NUMBER_REGEXP = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;

var DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;

var DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;

var WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;

var MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;

var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;</pre>

<h4>Example: Sample Regex in Perl</h4>

<pre class="color-example">
s/^\s+//        <span class="color-comment"># Remove leading whitespaces (substitute with empty string)</span>
s/\s+$//        <span class="color-comment"># Remove trailing whitespaces</span>
s/^\s+.*\s+$//  <span class="color-comment"># Remove leading and trailing whitespaces</span></pre>

<h3 id="Regex_Syntax">Regular Expression (Regex) Syntax</h3>

<p>A Regular Expression (or Regex) is a <em>pattern</em> (or <em>filter</em>) that describes a set of strings that matches the pattern. In other words, a regex <em>accepts</em> a certain set of strings and <em>rejects</em> the rest.</p>

<p>A regex  consists of a sequence of characters,  metacharacters (such as <code>.</code>,  <code>\d</code>, <code>\D</code>, <code>\</code>s, <code>\S</code>, <code>\w</code>, <code>\W</code>) and operators (such  as <code>+</code>, <code>*</code>, <code>?</code>, <code>|</code>, <code>^</code>). They are constructed by combining many smaller sub-expressions.</p>
<h4>Matching a Single Character</h4>

<p>The fundamental building blocks of a regex are patterns that match a <em>single</em> character. Most characters, including all letters (<code>a-z</code> and <code>A-Z</code>) and  digits (<code>0-9</code>), match itself. For example, the regex <code>x</code> matches substring <code>&quot;x&quot;</code>; <code>z</code> matches <code>&quot;z&quot;</code>; and <code>9</code> matches <code>&quot;9&quot;</code>.</p>
<p>Non-alphanumeric characters without special meaning in regex also matches itself. For example, <code>=</code> matches <code>&quot;=&quot;</code>; <code>@</code> matches <code>&quot;@&quot;</code>.</p>

<h4>Regex Special Characters and Escape Sequences</h4>
<h5>Regex's Special Characters</h5>
<p>These characters have special meaning in regex (I will discuss in detail in the later sections):</p>
<ul>
<li>metacharacter: dot (<code>.</code>)</li>
<li>bracket list: <code>[ ]</code></li>
<li>position anchors: <code>^</code>, <code>$</code></li>
<li>occurrence indicators: <code>+</code>, <code>*</code>, <code>?</code>, <code>{ }</code></li>
<li>parentheses: <code>( )</code></li>
<li>or: <code>|</code></li>
<li>escape and metacharacter: backslash (<code>\</code>)</li>
</ul>

<h5>Escape Sequences</h5>
<p>The characters listed above have special meanings in regex. To match these characters,  we need to prepend it with a backslash (<code>\</code>), known as <em>escape sequence</em>.  For examples, <code>\+</code> matches <code>&quot;+&quot;</code>; <code>\[</code> matches <code>&quot;[&quot;</code>; and <code>\.</code> matches <code>&quot;.&quot;</code>.</p>
<p>Regex also recognizes common escape sequences such as <code>\n</code> for newline, <code>\t</code> for tab, <code>\r</code> for carriage-return, <code>\nnn</code> for a up to 3-digit octal number, <code>\xhh</code> for a two-digit hex code, <code>\uhhhh</code> for a 4-digit Unicode, <code>\uhhhhhhhh</code> for a 8-digit Unicode.</p>

<h5>Code Example in Python</h5>

<pre class="color-example">
$ <strong>python3</strong>
&gt;&gt;&gt; <strong>import re</strong>   <span class="color-comment"># Need module 're' for regular expression</span>
<span class="color-comment"># Try find: re.findall(regexStr, inStr) -&gt; matchedStrList
# r'...' denotes raw strings which ignore escape code, i.e., r'\n' is '\'+'n'</span>
&gt;&gt;&gt; <strong>re.findall(r'a', 'abcabc')</strong>
['a', 'a']
&gt;&gt;&gt; <strong>re.findall(r'=', 'abc=abc')</strong>   <span class="color-comment"># '=' is not a special regex character</span>
['=']
&gt;&gt;&gt; <strong>re.findall(r'\.', 'abc.com')</strong>  <span class="color-comment"># '.' is a special regex character, need regex escape sequence</span>
['.']
&gt;&gt;&gt; <strong>re.findall('\\.', 'abc.com')</strong>  <span class="color-comment"># You need to write \\ for \ in regular Python string</span>
['.']</pre>

<h5>Code Example in JavaScript</h5>
<p>[TODO]</p>

<h5>Code Example in Java</h5>
<p>[TODO]</p>

<h4>Matching a Sequence of Characters (String or Text)</h4>

<h5>Sub-Expressions</h5>
<p>A regex is constructed by combining many smaller <em>sub-expressions</em> or <em>atoms</em>. For example, the regex <code>Friday</code> matches  the string &quot;<code>Friday</code>&quot;. The matching, by default, is case-sensitive, but can be set to case-insensitive via  modifier.</p>



<h4>OR (<span class="font-code">|</span>) Operator</h4>

<p>You can provide <em>alternatives</em> using the &quot;OR&quot; operator, denoted by a vertical bar <code>'|'</code>. For example, the regex <code>four|for|floor|4</code> accepts strings &quot;<code>four</code>&quot;, &quot;<code>for</code>&quot;, &quot;<code>floor</code>&quot; or &quot;<code>4</code>&quot;.</p>

<h4>Bracket List (Character Class) <span class="font-code">[...]</span>, <span class="font-code">[^...]</span>, <span class="font-code">[.-.]</span></h4>

<p>A <em>bracket expression</em> is <em>a list of characters</em> enclosed by <code>[ ]</code>, also called <em>character class</em>. It matches ANY ONE character in the list.  However, if the first character of the list is the caret (<code>^</code>), then it matches ANY ONE character NOT in the list.  For example, the regex <code>[02468]</code> matches a single digit <code>0</code>, <code>2</code>, <code>4</code>, <code>6</code>, or <code>8</code>; the regex <code>[^02468]</code> matches any single character other than <code>0</code>, <code>2</code>, <code>4</code>, <code>6</code>, or <code>8</code>.</p>

<p>Instead of listing all characters, you could use a <em>range expression</em> inside the bracket.  A range expression consists of two characters separated by a hyphen (<code>-</code>).  It matches any single character that sorts between the two characters, inclusive. For example, <code>[a-d]</code> is the same as <code>[abcd]</code>.  You could include a caret (<code>^</code>) in front of the range to <em>invert</em> the matching.  For example, <code>[^a-d]</code> is equivalent to <code>[^abcd]</code>.</p>

<p>Most of the special regex characters lose their meaning inside bracket list, and can be used as they are; except <code>^</code>, <code>-</code>, <code>]</code> or <code>\</code>.</p>
<ul>
<li>To include a <code>]</code>, place it first in the list, or use escape <code>\]</code>.</li>
<li>To include a <code>^</code>, place it anywhere but first, or use escape <code>\^</code>.</li>
<li>To include a <code>-</code> place it last, or use escape <code>\-</code>.</li>
<li>To include a <code>\</code>, use escape <code>\\</code>.</li>
<li>No escape needed for the other characters such as <code>.</code>, <code>+</code>, <code>*</code>, <code>?</code>, <code>(</code>, <code>)</code>, <code>{</code>, <code>}</code>, and etc, inside the bracket list</li>
<li>You can also include metacharacters (to be explained in the next section), such as <code>\w</code>, <code>\W</code>, <code>\d</code>, <code>\D</code>, <code>\s</code>, <code>\S</code> inside the bracket list.</li>
</ul>

<h5>Name Character Classes in Bracket List (For Perl Only?)</h5>

<p>Named (POSIX) classes of characters are pre-defined within bracket expressions.  They are:</p>

<ul>
<li><code>[:alnum:]</code>, <code>[:alpha:]</code>, <code>[:digit:]</code>: letters+digits, letters, digits.</li>
<li><code>[:xdigit:]</code>: hexadecimal digits.</li>
<li><code>[:lower:]</code>, <code>[:upper:]</code>: lowercase/uppercase letters.</li>
<li><code>[:cntrl:]</code>: Control characters</li>
<li><code>[:graph:]</code>: printable characters, except space.</li>
<li><code>[:print:]</code>: printable characters, include space.</li>
<li><code>[:punct:]</code>: printable characters, excluding letters and digits.</li>
<li><code>[:space:]</code>: whitespace</li>
</ul> 
 
<p>For example, <code>[[:alnum:]]</code> means <code>[0-9A-Za-z]</code>.  (Note that the square brackets in these class names are part of the symbolic names, and must be included in addition to the square brackets delimiting the bracket list.)</p>

<h4>Metacharacters <span class="font-code">.</span>, <span class="font-code">\w</span>, <span class="font-code">\W</span>, <span class="font-code">\d</span>, <span class="font-code">\D</span>, <span class="font-code">\s</span>, <span class="font-code">\S</span></h4>

<p>A <em>metacharacter</em> is a symbol with a special meaning inside a regex.</p>

<ul>
<li>The metacharacter dot (<code>.</code>) matches any single character except newline <code>\n</code> (same as <code>[^\n]</code>).  For example, <code>...</code> matches any 3 characters (including alphabets, numbers, whitespaces, but except newline); <code>the..</code> matches &quot;<code>there</code>&quot;, &quot;<code>these</code>&quot;, &quot;<code>the&nbsp;&nbsp;</code>&quot;, and so on.</li>

<li><code>\w</code> (word character) matches any single letter, number or underscore (same as <code>[a-zA-Z0-9_]</code>).  The uppercase counterpart <code>\W</code> (non-word-character) matches any single character that doesn't match by <code>\w</code> (same as <code>[^a-zA-Z0-9_]</code>).</li>

<li>In regex, the uppercase metacharacter is always the <em>inverse</em> of the lowercase counterpart.</li>

<li><code>\d</code> (digit) matches any single digit (same as <code>[0-9]</code>). The uppercase counterpart <code>\D</code> (non-digit) matches any single character that is not a digit (same as <code>[^0-9]</code>).</li>

<li><code>\s</code> (space) matches any single whitespace (same as <code>[ \t\n\r\f]</code>, blank, tab, newline, carriage-return and form-feed). The uppercase counterpart <code>\S</code> (non-space) matches any single character that doesn't match by <code>\s</code> (same as <code>[^ \t\n\r\f]</code>).</li>

</ul>

<p>Examples:</p>
<pre class="color-example">\s\s      <span class="color-comment"># Matches two spaces</span>
\S\S\s    <span class="color-comment"># Two non-spaces followed by a space</span>
\s+       <span class="color-comment"># One or more spaces</span>
\S+\s\S+  <span class="color-comment"># Two words (non-spaces) separated by a space</span></pre>

<h4>Backslash (<span class="font-code">\</span>) and Regex Escape Sequences</h4>

<p>Regex uses backslash (<code>\</code>) for two purposes:</p>
<ol>
<li>for <em>metacharacters</em> such as <code>\d</code> (digit), <code>\D</code> (non-digit), <code>\s</code> (space), <code>\S</code> (non-space), <code>\w</code> (word), <code>\W</code> (non-word).</li>
<li>to escape special regex characters, e.g., <code>\.</code> for <code>.</code>, <code>\+</code> for <code>+</code>, <code>\*</code> for <code>*</code>, <code>\?</code> for <code>?</code>. You also need to write <code>\\</code> for <code>\</code> in regex to avoid ambiguity.</li>
<li>Regex also recognizes <code>\n</code> for newline, <code>\t</code> for tab, etc.</li>
</ol>
<p>Take note that in many programming languages (C, Java, Python), backslash (<code>\</code>) is also used for escape sequences in string, e.g., <code>&quot;\n&quot;</code> for newline, <code>&quot;\t&quot;</code> for tab, and you also need to write <code>&quot;\\&quot;</code> for <code>\</code>. Consequently, to write regex pattern <code>\\</code> (which matches one <code>\</code>) in these languages, you need to write <code>&quot;\\\\&quot;</code> (two levels of escape!!!). Similarly, you need to write <code>&quot;\\d&quot;</code> for regex metacharacter <code>\d</code>. This is cumbersome and error-prone!!!</p>

<h4>Occurrence Indicators (Repetition Operators): <span class="font-code">+</span>, <span class="font-code">*</span>, <span class="font-code">?</span>, <span class="font-code">{m}</span>, <span class="font-code">{m,n}</span>, <span class="font-code">{m,}</span></h4>

<p>A regex sub-expression may be followed by an <em>occurrence indicator</em> (aka <em>repetition operator</em>):</p>
<ul>
<li><code>?</code>: The preceding item is optional and matched at most once (i.e., occurs 0 or 1 times or optional).</li>
<li><code>*</code>: The preceding item will be matched zero or more times, i.e., <code>0+</code></li>
<li><code>+</code>: The preceding item will be matched one or more times, i.e., <code>1+</code></li>
<li><code>{m}</code>: The preceding item is matched exactly m times.</li>
<li><code>{m,}</code>: The preceding item is matched m or more times, i.e., <code>m+</code></li>
<li><code>{m,n}</code>: The preceding item is matched at least m times, but not more than n times.</li>
</ul>

<p>For example: The regex <code>xy{2,4}</code> accepts &quot;<code>xyy</code>&quot;, &quot;<code>xyyy</code>&quot; and &quot;<code>xyyyy</code>&quot;.</p>

<h4>Modifiers</h4>

<p>You can apply modifiers to a regex to tailor its behavior, such as global, case-insensitive, multiline, etc. The ways to apply modifiers differ among languages.</p>
<p>In Perl, you can attach <em>modifiers</em> after a regex, in the form of <code>/.../<em>modifiers</em></code>. For examples:</p>
<pre class="color-example">m/abc/i     <span class="color-comment"># case-insensitive matching</span>
m/abc/g     <span class="color-comment"># global (Match ALL instead of match first)</span>
</pre>

<p>In Java, you apply modifiers when compiling the regex <code>Pattern</code>. For example,</p>
<pre class="color-example">
Pattern p1 = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);  <span class="color-comment">// for case-insensitive matching</span>
Pattern p2 = Pattern.compile(regex, Pattern.MULTILINE);         <span class="color-comment">// for multiline input string</span>
Pattern p3 = Pattern.compile(regex, Pattern.DOTALL);         <span class="color-comment">   // Dot (.) matches all characters including newline</span></pre>

<p>The commonly-used modifer modes are:</p>

<ul>
<li>Case-Insensitive mode (or <code>i</code>): case-insensitive matching for letters.</li>
<li>Global (or <code>g</code>): match All instead of first match.</li>
<li>Multiline mode (or <code>m</code>): affect <code>^</code>, <code>$</code>, <code>\A</code> and <code>\Z</code>. In multiline mode, <code>^</code> matches start-of-line or start-of-input; <code>$</code> matches end-of-line or end-of-input, <code>\A</code> matches start-of-input; <code>\Z</code> matches end-of-input.</li>
<li>Single-line mode (or <code>s</code>): Dot (<code>.</code>) will match all characters, including newline.</li>
<li>Comment mode (or <code>x</code>): allow and ignore embedded comment starting with <code>#</code> till end-of-line (EOL).</li>
<li>more...</li>
</ul>

<h4>Greediness, Laziness and Backtracking for Repetition Operators</h4>

<p><span class="line-heading">Greediness of Repetition Operators <span class="font-code">*</span>, <span class="font-code">+</span>, <span class="font-code">?</span>, <span class="font-code">{m,n}</span></span>: The repetition operators are <em>greedy operators</em>, and by default grasp as many characters as possible for a match. For example, the regex  <code>xy{2,4}</code> try to match for &quot;<code>xyyyy</code>&quot;, then &quot;<code>xyyy</code>&quot;, and then &quot;<code>xyy</code>&quot;.</p>

<p><span class="line-heading">Lazy Quantifiers <span class="font-code">*?</span>, <span class="font-code">+?</span>, <span class="font-code">??</span>, <span class="font-code">{m,n}?</span>,  <span class="font-code">{m,}?</span></span>, : You can put an extra <code>?</code> after the repetition operators to curb its greediness (i.e., stop at the shortest match). For example,</p>

<pre class="color-example">
input = &quot;The &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; instances&quot;
regex = &lt;code&gt;.*&lt;/code&gt; matches &quot;&lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;&quot;
But
regex = &lt;code&gt;.*?&lt;/code&gt; produces two matches: &quot;&lt;code&gt;first&lt;/code&gt;&quot; and &quot;&lt;code&gt;second&lt;/code&gt;&quot;</pre>

<p><span class="line-heading">Backtracking</span>: If a regex reaches a state where a match cannot be completed, it backtracks by unwinding one character from the greedy match. For example, if the regex <code>z*zzz</code> is matched against the string &quot;<code>zzzz</code>&quot;, the <code>z*</code> first matches &quot;<code>zzzz</code>&quot;; unwinds to match &quot;<code>zzz</code>&quot;; unwinds to match &quot;<code>zz</code>&quot;; and finally unwinds to match &quot;<code>z</code>&quot;, such that the rest of the patterns can find a match.</p>

<p><span class="line-heading">Possessive Quantifiers <span class="font-code">*+</span>, <span class="font-code">++</span>, <span class="font-code">?+</span>, <span class="font-code">{m,n}+</span>, <span class="font-code">{m,}+</span></span>: You can put an extra <code>+</code> to the repetition operators to disable backtracking, even it may result in match failure. e.g, <code>z++z</code> will not match <code>&quot;zzzz&quot;</code>. This feature might not be supported in some languages.</p>

<h4>Position Anchors <span class="font-code">^</span>, <span class="font-code">$</span>, <span class="font-code">\b</span>, <span class="font-code">\B</span>, <span class="font-code">\&lt;</span>, <span class="font-code">\&gt;</span>, <span class="font-code">\A</span>, <span class="font-code">\Z</span></h4>

<p><em>Positional anchors</em> DO NOT match actual character, but matches <em>position</em> in a string, such as start-of-line, end-of-line, start-of-word, and end-of-word.</p>

<ul>

<li><span class="font-code">^</span> and <span class="font-code">$</span>: The <code>^</code> matches the start-of-line. The <code>$</code> matches the end-of-line excluding newline, or end-of-input (for input not ending with newline). These are the most commonly-used position anchors. For examples,
  <pre class="color-example">ing$           <span class="color-comment"># ending with 'ing'</span>
^testing 123$  <span class="color-comment"># Matches only one pattern. Should use equality comparison instead.</span>
^[0-9]+$       <span class="color-comment"># Numeric string</span></pre>
</li>

<li><span class="font-code">\b</span> and <span class="font-code">\B</span>: The  <code>\b</code> matches the boundary of a word (i.e., start-of-word or end-of-word); and <code>\B</code> matches inverse of <code>\b</code>, or non-word-boundary. For examples,
<pre class="color-example">
\bcat\b        <span class="color-comment"># matches the word &quot;cat&quot; in input string &quot;This is a cat.&quot;
               # but does not match input &quot;This is a catalog.&quot;</span></pre>
</li>

<li><code>\&lt;</code> and <code>\&gt;</code>: The <code>\&lt;</code> and <code>\&gt;</code> match the start-of-word and end-of-word, respectively (compared with <code>\b</code>, which can match both the start and end of a word).</li>

<li><span class="font-code">\A</span> and <span class="font-code">\Z</span>: The <code>\A</code> matches the start of the input. The <code>\Z</code> matches the end of the input. <br />
  They are different from <code>^</code> and <code>$</code> when it comes to matching input with multiple lines. <code>^</code> matches at the start of the string and after each line break, while <code>\A</code> only matches at the start of the string. <code>$</code> matches at the end of the string and before each line break, while <code>\Z</code> only matches at the end of the string. For examples,
  <pre class="color-example">
$ <strong>python3</strong>
<span class="color-comment"># Using ^ and $ in multiline mode</span>
&gt;&gt;&gt; <strong>p1 = re.compile(r'^.+$', re.MULTILINE)</strong>  <span class="color-comment"># . for any character except newline</span>
&gt;&gt;&gt; <strong>p1.findall('testing\ntesting')</strong>
['testing', 'testing']
&gt;&gt;&gt; <strong>p1.findall('testing\ntesting\n')</strong>
['testing', 'testing']
   <span class="color-comment"># ^ matches start-of-input or after each line break at start-of-line
   # $ matches end-of-input or before line break at end-of-line
   # newlines are NOT included in the matches</span>

<span class="color-comment"># Using \A and \Z in multiline mode</span>
&gt;&gt;&gt; <strong>p2 = re.compile(r'\A.+\Z', re.MULTILINE)</strong>
&gt;&gt;&gt; <strong>p2.findall('testing\ntesting')</strong>
[]    <span class="color-comment"># This pattern does not match the internal \n</span>
&gt;&gt;&gt; <strong>p3 = re.compile(r'\A.+\n.+\Z', re.MULTILINE)</strong>  <span class="color-comment"># to match the internal \n</span>
&gt;&gt;&gt; <strong>p3.findall('testing\ntesting')</strong>
['testing\ntesting']
&gt;&gt;&gt; p3.findall('testing\ntesting\n')
[]    <span class="color-comment"># This pattern does not match the trailing \n</span>
   <span class="color-comment"># \A matches start-of-input and \Z matches end-of-input</span></pre>
</li>
</ul>

<h4>Capturing Matches via Parenthesized Back-References &amp; Matched Variables <span class="font-code">$1</span>, <span class="font-code">$2</span>, ...</h4>

<p>Parentheses <code>( )</code> serve two purposes in regex:</p>

<ol>
<li>Firstly, parentheses <code>( )</code> can be used to group sub-expressions for overriding the precedence or applying a repetition operator.  For example,<code> </code><code>(abc)+</code> (accepts <code>abc</code>, <code>abcabc</code>, <code>abcabcabc</code>, ...) is different from <code>abc+</code> (accepts <code>abc</code>, <code>abcc</code>, <code>abccc</code>, ...).</li>

<li>Secondly, parentheses are used to provide the so called <em>back-references</em> (or <em>capturing groups</em>).  A back-reference contains the <em>matched substring</em>.  For examples, the regex <code>(\S+)</code> creates one back-reference <code>(\S+)</code>, which contains the first word (consecutive non-spaces) of the input string; the regex <code>(\S+)\s+(\S+)</code> creates two back-references: <code>(\S+)</code> and another <code>(\S+)</code>, containing the first two words, separated by one or more spaces <code>\s+</code>.</li>
</ol>

<p> These back-references (or capturing groups) are stored in special variables <code>$1</code>, <code>$2</code>, … (or <code>\1</code>, <code>\2</code>, ... in Python), where <code>$1 </code>contains the substring matched the first pair of parentheses, and so on. For example, <code>(\S+)\s+(\S+)</code> creates two back-references which matched with the first two words. The matched words are stored in <code>$1</code> and <code>$2</code> (or <code>\1</code> and <code>\2</code>), respectively. </p>

<p>Back-references are important  to manipulate the string. Back-references can be used in the substitution string as well as the pattern. For examples,</p>

<pre class="color-example">
<span class="color-comment"># Swap the first and second words separated by one space</span>
s/(\S+) (\S+)/$2 $1/;                     <span class="color-comment"># Perl</span>
re.sub(r'(\S+)  (\S+)', r'\2 \1', inStr)  <span class="color-comment"># Python</span>

<span class="color-comment"># Remove duplicate word</span>
s/(\w+)  $1/$1/;                    <span class="color-comment"># Perl</span>
re.sub(r'(\w+)  \1', r'\1', inStr)  <span class="color-comment"># Python</span></pre>


<h4>(Advanced) Lookahead/Lookbehind, Groupings and Conditional</h4>

<p>These feature might not be supported in some languages.</p>

<h5>Positive Lookahead <span class="font-code">(?=<em>pattern</em>)</span></h5>
<p>The <code>(?=pattern)</code> is known as <em>positive lookahead</em>. It performs the match, but does not capture the match, returning only the result: match or no match. It is also called <em>assertion</em> as it does not consume any characters in matching. For example, the following complex regex is used to match email addresses by AngularJS:</p>

<pre class="color-example">
^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&amp;'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&amp;'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$</pre>
 
<p>The first positive lookahead patterns <code>^(?=.{1,254}$)</code> sets the maximum length to 254 characters. The second positive lookahead <code>^(?=.{1,64}@)</code> sets  maximum of 64 characters before the <code>'@'</code> sign for the username.</p>

<h5>Negative Lookahead <span class="font-code">(?!<em>pattern</em>)</span></h5>
<p>Inverse of <code>(?=pattern)</code>. Match if <code>pattern</code> is missing. For example, <code>a(?=b)</code> matches <code>'a'</code> in <code>'abc'</code> (not consuming <code>'b'</code>); but not <code>'acc'</code>. Whereas <code>a(?!b)</code> matches <code>'a'</code> in <code>'acc'</code>, but not <code>abc</code>.</p>

<h5>Positive Lookbehind <span class="font-code">(?&lt;=<em>pattern</em>)</span></h5>
<p>[TODO]</p>

<h5>Negative Lookbehind <span class="font-code">(?&lt;!<em>pattern</em>)</span></h5>
<p>[TODO]</p>

<h5>Non-Capturing Group <span class="font-code">(?:<em>pattern</em>)</span></h5>
<p>Recall that you can use Parenthesized Back-References to capture the matches. To disable capturing, use <code>?:</code> inside the parentheses in the form of <code>(?:pattern)</code>. In other words, <code>?:</code> disables the creation of a capturing group, so as not to create an unnecessary capturing group.</p>

<p>Example: [TODO]</p>

<h5>Named Capturing Group <span class="font-code">(?&lt;<em>name</em>&gt;<em>pattern</em>)</span></h5>
<p>The capture group can be referenced later by <code><em>name</em></code>.</p>

<h5>Atomic Grouping <span class="font-code">(&gt;<em>pattern</em>)</span></h5>
<p>Disable backtracking, even if this may lead to match failure.</p>

<h5>Conditional <span class="font-code">(?(<em>Cond</em>)<em>then</em>|<em>else</em>)</span></h5>
<p>[TODO]</p>

<h4>Unicode</h4>
<p>The metacharacters <code>\w</code>, <code>\W</code>, (word and non-word character), <code>\b</code>, <code>\B</code> (word and non-word boundary) recongize Unicode characters.</p>
<p>[TODO]</p>

<h3 id="prog_lang">Regex in Programming Languages</h3>

<p><span class="line-heading">Python</span>: See &quot;<a href="../webprogramming/Python1_Basics.html">Python <code>re</code> module for Regular Expression</a>&quot;</p>

<p><span class="line-heading">Java</span>: See &quot;<a href="../java/Java_Regexe.html">Regular Expressions in Java</a>&quot;</p>

<p><span class="line-heading">JavaScript</span>: See &quot;<a href="../webprogramming/JavaScript_Introduction.html#regex">Regular Expression in JavaScript</a>&quot;</p>

<p><span class="line-heading">Perl</span>: See &quot;<a href="../webprogramming/Perl2_Regexe.html#regex">Regular Expressions in Perl</a>&quot;</p>

<p><span class="line-heading">PHP</span>: [Link]</p>

<p><span class="line-heading">C/C++</span>: [Link]</p>